//this file was generated by ../../../../../../scripts/onnx_generator/OperatorTemplate.py
#include "operator__ai_onnx__flatten__11.h"
#include "tracing.h"
#include "utils.h"

operator_status
prepare_operator__ai_onnx__flatten__11(
    node_context *ctx
)
{
    TRACE_ENTRY(1);

    TRACE_NODE(2, true, ctx->onnx_node);

    /* UNCOMMENT AS NEEDED */

    Onnx__TensorProto *i_X = searchInputByName(ctx, 0);

    TRACE_TENSOR(2, true, i_X);

    Onnx__TensorProto *o_Y = searchOutputByName(ctx, 0);

    /* ALLOCATE AND INITIALIZE CONTEXT HERE IF NEEDED */

    int inout_dim = 1;
    for(int i =0; i < i_X->n_dims; i++){
        inout_dim *= (i_X->dims[i] == 0? 1 : i_X->dims[i]);
    }

    o_Y->n_dims       = 1;
    o_Y->dims         = (int64_t*)malloc(o_Y->n_dims * sizeof(int64_t));
    o_Y->has_raw_data = 0;
    o_Y->data_type    = ONNX__TENSOR_PROTO__DATA_TYPE__FLOAT;
    o_Y->n_float_data = inout_dim;

    o_Y->dims[0] = inout_dim;
    // o_Y->dims[1] = 1;
    // o_Y->dims[2] = 1;
    // o_Y->dims[3] = 1;

    /* MALLOC OUTPUT TENSORS HERE */

    mallocTensorData(o_Y);

    // TRACE_TENSOR(2, true, o_Y);

    /* CHOOSE EXECUTER AND CONTEXT HERE */
    /* YOU MAY USE THE GENERATED RESOLVER */

    ctx->executer = resolve_operator__ai_onnx__flatten__11(ctx);
    // ctx->executer_context = op_ctx;

    TRACE_EXIT(1);

    /* CHANGE RETURN CODE IF THIS PREPARER IS VALID */
    //return OP_ENOSYS;
    return OP_OK;
}